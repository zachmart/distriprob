"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {int} from "../interfaces/int";
import {float} from "../interfaces/float";
import {RandomNumGen} from "../interfaces/RandomNumGen";
import {IRandomState} from "../interfaces/IRandomState";

import {Integer as IntegerAlias} from "../dataTypes/Integer";
const Integer = IntegerAlias;

import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Comparison as ComparisonAlias} from "../basicFunctions/Comparison";
const Comparison = ComparisonAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {Conversion as ConversionAlias} from "../core/Conversion";
const Conversion = ConversionAlias;

import {Bitwise as BitwiseAlias} from "../basicFunctions/Bitwise";
const Bitwise = BitwiseAlias;

import {Basic as BasicAlias} from "../basicFunctions/Basic";
const Basic = BasicAlias;

import {Pow as PowAlias} from "../basicFunctions/Pow";
const Pow = PowAlias;

import {WELL512A as WELL512AAlias, WELL512AState} from "./WELL512A";
const WELL512A = WELL512AAlias;

import {WELL1024A as WELL1024AAlias, WELL1024AState} from "./WELL1024A";
const WELL1024A = WELL1024AAlias;

import {ARC4 as ARC4Alias, ARC4State} from "./ARC4";
const ARC4 = ARC4Alias;

import {P as PAlias} from "../core/P";
const P = PAlias;
export type P = PAlias;


export class Random {
  public static isState(x: any): x is IRandomState {
    return WELL512A.isState(x) || WELL1024A.isState(x) || ARC4.isState(x);
  }

  private gen: RandomNumGen;
  private width: number;

  constructor(
    seed: number | string | null | undefined | IRandomState,
    type: "WELL512A" | "WELL1024A" | "ARC4" | null | undefined
  ) {
    if (Random.isState(seed)) {
      if (typeof type !== "undefined" && type !== null && type !== seed.type) {
        throw new Error(`Seed of type ${seed.type} state does not match ${""
          }given parameter type ${type}.`);
      } else {
        type = seed.type;
      }
    }

    if (type === "WELL512A") {
      this.gen = new WELL512A(<number | string | null | undefined | WELL512AState>seed);
    } else if (type === "WELL1024A") {
      this.gen = new WELL1024A(<number | string | null | undefined | WELL1024AState>seed);
    } else if (type === "ARC4") {
      this.gen = new ARC4(<number | string | null | undefined | ARC4State>seed);
    } else if (typeof type === "undefined" || type === null) {
      // default
      this.gen = new WELL1024A(<number | string | null | undefined | WELL1024AState>seed);
    } else {
      throw new Error("Unrecognized RNG type");
    }

    this.width = this.gen.outputWidth;
  }

  public state(): IRandomState {
    return this.gen.state();
  }

  public float(prec: P): float {
    let num: int = C.I_0; Core.numberToIntUnchecked(this.gen.next());
    let denom: int = C.I_1;
    let x = 0;
    let currentLength: number;

    while ((currentLength = Bitwise.lengthI(num)) < prec.binaryDigits) {
      num = Bitwise.orI(
        Bitwise.leftShiftI(num, this.width),
        Core.numberToIntUnchecked(this.gen.next())
      );
      denom = Bitwise.leftShiftI(denom, this.width);
    }

    const rightShiftAmount = currentLength - prec.binaryDigits;

    if (rightShiftAmount > 0) {
      num = Bitwise.rightShiftI(num, rightShiftAmount);
      denom = Bitwise.rightShiftI(denom, rightShiftAmount);
    }

    return Basic.divideFF(
      Conversion.intToFloat(
        Basic.addII(num, Core.numberToIntUnchecked(x)),
        prec,
        true
      ),
      Conversion.intToFloat(denom, prec, true),
      prec
    );
  }
}


