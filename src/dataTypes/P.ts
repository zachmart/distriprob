"use strict";

/**
 * (C) Copyright Zachary Martin 2018.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


export class P {
  public static DECIMAL_DIGITS_PER_BINARY_DIGIT: number;
  public static BINARY_DIGITS_PER_DECIMAL_DIGIT: number;

  public static init0(): void {
    P.DECIMAL_DIGITS_PER_BINARY_DIGIT = 0.3010299956639812;
    P.BINARY_DIGITS_PER_DECIMAL_DIGIT = 3.321928094887362;
  }

  public readonly baseDigits: number;
  public readonly baseDigitsInt: int;
  public readonly binDigits: number;
  public readonly decDigits: number;
  public readonly type: "base" | "dec" | "bin";
  public readonly quadraticConvergenceSteps: number;
  public readonly epsilon: float;
  public readonly maxSafeInt: float;

  constructor(digits: number, type: "base" | "dec" | "bin") {
    if (type === "base") {
      this.binDigits = digits * C.POWER_OF_TWO_FOR_BASE;
      this.decDigits = Math.floor(P.DECIMAL_DIGITS_PER_BINARY_DIGIT * this.binDigits);
      this.baseDigits = digits + 1;
    } else if (type === "dec") {
      this.binDigits = Math.ceil(P.BINARY_DIGITS_PER_DECIMAL_DIGIT * digits);
      this.decDigits = digits;
      this.baseDigits = Math.ceil(this.binDigits / C.POWER_OF_TWO_FOR_BASE) + 1;
    } else if (type === "bin") {
      this.binDigits = digits;
      this.decDigits = Math.floor(P.DECIMAL_DIGITS_PER_BINARY_DIGIT * digits);
      this.baseDigits = Math.ceil(digits / C.POWER_OF_TWO_FOR_BASE) + 1;
    } else {
      throw new DomainError(
        "P",
        "constructor",
        {type: {value: type, expectedType: "string"}},
        `type should be "base" | "dec" | "bin", given ${type}`
      );
    }

    this.baseDigitsInt = Core.numberToIntUnchecked(this.baseDigits);
    this.type = type;
    this.quadraticConvergenceSteps = P.quadraticConvergenceSteps(this.baseDigits);
    this.epsilon = P.epsilon(this.baseDigits);
    this.maxSafeInt = P.maxSafeInt(this.baseDigits);
  }

  public static instance(x: any): x is P {
    return typeof x === "object" && x !== null && typeof x.baseDigits === "number" &&
      Core.instanceI(x.baseDigitsInt) && typeof x.binDigits === "number" &&
      typeof x.decDigits === "number" &&
      (x.type === "base" || x.type === "dec" || x.type === "bin") &&
      typeof x.quadraticConvergenceSteps === "number";
  }

  private static epsilon(baseDigits: number): float {
    return new FloatingPoint(
      C.I_2,
      Core.numberToIntUnchecked(1 - baseDigits)
    );
  }

  private static maxSafeInt(baseDigits: number): float {
    return new FloatingPoint(
      new Integer(
        false,
        Uint32Array.from(Array(baseDigits - 1).fill(C.BASE_MINUS_ONE))
      ),
      Core.numberToIntUnchecked(baseDigits - 2)
    );
  }

  private static quadraticConvergenceSteps(baseDigits: number): number {
    return Math.ceil(Math.log2((baseDigits * C.POWER_OF_TWO_FOR_BASE + 1) / 50));
  }
}


// *** imports come at end to avoid circular dependency ***

import {int} from "../interfaces/int";
import {float} from "../interfaces/float";

import {Integer as IntegerAlias} from "./Integer";
const Integer = IntegerAlias;

import {FloatingPoint as FloatingPointAlias} from "./FloatingPoint";
const FloatingPoint = FloatingPointAlias;

import {C as CAlias} from "../constants/C";
const C = CAlias;

import {Core as CoreAlias} from "../core/Core";
const Core = CoreAlias;

import {DomainError as DomainErrorAlias} from "../errors/DomainError";
const DomainError = DomainErrorAlias;